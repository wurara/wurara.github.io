---
layout: post
title: 后端开发
subtitle: 后端开发
cover-img: /assets/img/path.jpg
thumbnail-img: /assets/img/thumb.png
share-img: /assets/img/path.jpg
tags: [learn]
---


# Java基础常见问题总结(上)

## [位移运算符](https://javaguide.cn/java/basis/java-basic-questions-01.html#%E2%AD%90%EF%B8%8F%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6)

1. 首位：0是正式，1是负数
2. 原码：二进制数
3. 反码：除了符号位外，01取反
4. 补码：正数不变，负数是反码+1

## [包装类型缓存机制](https://javaguide.cn/java/basis/java-basic-questions-01.html#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88)

1. `Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `TRUE` or `FALSE`。
2. 如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作

## [浮点数精度丢失](https://javaguide.cn/java/basis/java-basic-questions-01.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E6%9C%89%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%A3%8E%E9%99%A9)

1. BigDecimal
2. 超大数字使用BigInteger

## [成员变量与局部变量的区别](https://javaguide.cn/java/basis/java-basic-questions-01.html#⭐️成员变量与局部变量的区别)

## `char` 在 Java 中占两个字节

# Java基础常见问题总结(中)

## [== 和 equals() 的区别](https://javaguide.cn/java/basis/java-basic-questions-02.html#object-%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B)

1. 对于基本数据类型来说，`==` 比较的是值。

2. 对于引用数据类型来说，`==` 比较的是对象的内存地址。

3. 类没有重写 `equals()`方法：通过`equals()`比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 `Object`类`equals()`方法。

   类重写了 `equals()`方法：一般我们都重写 `equals()`方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。

## [重写 equals() 时必须重写 hashCode() ](https://javaguide.cn/java/basis/java-basic-questions-02.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-hashcode)

1. 两个相等的对象的 `hashCode` 值必须是相等
2. **例如重写 `equals()` 时没有重写 `hashCode()` 方法的话，使用 `HashMap` 可能会出现问题**

## [String、StringBuffer、StringBuilder](https://javaguide.cn/java/basis/java-basic-questions-02.html#⭐️string、stringbuffer、stringbuilder-的区别)

1. `StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的
2. 被 `final` 关键字修饰之后的 `String` 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。

# Java基础常见问题总结(下)

## [throwable](https://javaguide.cn/java/basis/java-basic-questions-03.html#%E5%BC%82%E5%B8%B8)

1. Checked Exception：必须catch
2. Unchecked Exception
3. final：
   1. finally 之前虚拟机被终止
   2. 程序所在的线程死亡
   3. 关闭 CPU。
4. 使用 **try-with-resources** 代替try-catch-finally
   1. 适用于任何实现 `java.lang.AutoCloseable`或者 `java.io.Closeable` 的对象

![types-of-exceptions-in-java](C:\Users\boss\Desktop\note\java\img\types-of-exceptions-in-java.png)

## [反射](https://javaguide.cn/java/basis/java-basic-questions-03.html#%E2%AD%90%EF%B8%8F%E5%8F%8D%E5%B0%84)

1. 灵活性和动态性、解耦合和通用性、框架开发的基础
2. 性能开销、安全性问题、代码可读性和维护性

## 网络协议

1. TCP/IP 四层： 
   1. 应用层
   2. 传输层
   3. 网络层
   4. 网络接口层

![tcp-ip-4-model](C:\Users\boss\Desktop\note\java\img\tcp-ip-4-model.png)

## [序列化](https://javaguide.cn/java/basis/java-basic-questions-03.html#%E2%AD%90%EF%B8%8F%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96)

1. 不想进行序列化的变量，使用 `transient` 关键字修饰
1. `static` 变量因为不属于任何对象(Object)，所以无论有没有 `transient` 关键字修饰，均不会被序列化

## [IO](https://javaguide.cn/java/basis/java-basic-questions-03.html#i-o)

1. 缓冲流用于减少读取次数，提高性能

2. 随机访问流：如RandomAccessFile（实现文件断点传输）

3. IO工具的设计模式

   1. 装饰器模式：增强原有io流的功能
   2. 适配器模式
   3. 工厂模式
   4. 观察者模式

4. IO模型

   用户发起IO申请，然后内核执行IO命令。

   1. BIO(Blocking I/O) 同步阻塞 IO 模型 。
   2. NIO (Non-blocking/New I/O)I/O 多路复用模型
   3. AIO (Asynchronous I/O)异步 IO 模型

# 基础重要知识点

## JAVA 中只有值传递

## [代理模式](https://javaguide.cn/java/basis/proxy.html#_1-代理模式)

1. 静态代理
2. 动态代理
   1. JDK 动态代理机制（性能更好）
      1. InvocationHandler
         1. invoke
      2. Proxy
   2. CGLIB 动态代理机制（更加灵活）
      1. MethodInterceptor
         1. intercept
      2. Enhancer

## SPI

1. API
2. SPI：SLF4J

# [Java集合常见问题总结(上)](https://javaguide.cn/java/collection/java-collection-questions-01.html)

![java-collection-hierarchy](C:\Users\boss\Desktop\note\java\img\java-collection-hierarchy.png)

1. List
   1. ArrayList：线程不安全.扩容之后容量都会变为原来的 1.5 倍左右
      1. CopyOnWriteArrayList：线程安全数组。fail-fast 和 fail-safe 
   2. Vector：线程安全
   3. LinkedList
2. Set
   1. HashSet：哈希表（基于 `HashMap` 实现）
   2. LinkedHashSet：链表和哈希表
   3. TreeSet：红黑树
3. Queue
   1. PriorityQueue
   2. DelayQueue
   3. ArrayDeque
4. Map
   1. HashMap：线程不安全
   2. LinkedHashMap
   3. Hashtable
   4. TreeMap

## Comparable 和 Comparator 的区别

1. Comparable 接口用于实现默认的排序（相当于装饰器，增强了没有实现这个接口的对象）
2. Comparator接口用于新建一个对比器（相当于适配器，使这个对象可以用于比较）

# [Java集合常见问题总结(下)](https://javaguide.cn/java/collection/java-collection-questions-02.html)

## `HashSet` 底层就是基于 `HashMap` 实现的。

## [TreeMap](https://javaguide.cn/java/collection/java-collection-questions-02.html#%E2%AD%90%EF%B8%8Fhashmap-%E5%92%8C-treemap-%E5%8C%BA%E5%88%AB)

1. 实现 NavigableMap 接口让 TreeMap 有了对集合内元素的搜索的能力
   1. 定向搜索
   2. 子集操作
   3. 逆序视图
   4. 边界操作

![treemap_hierarchy](C:\Users\boss\Desktop\note\java\img\treemap_hierarchy.png)

## [HashMap](https://javaguide.cn/java/collection/java-collection-questions-02.html#%E2%AD%90%EF%B8%8Fhashmap-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0)

1. **拉链法**解决冲突
1. jdk1.8后如果**拉链法**过长会切换为**红黑树**
3. 长度为2的幂次方
   1. hash散列时位运算更高效
   2. 更好均匀分布
   3. 扩容简单高效

## [ConcurrentHashMap](https://javaguide.cn/java/collection/java-collection-questions-02.html#%E2%AD%90%EF%B8%8Fconcurrenthashmap-%E5%92%8C-hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB)

1. 采用 `Node + CAS + synchronized` 保证线程安全，锁粒度更细，`synchronized` 只锁定当前链表或红黑二叉树的首节点。
1. key 和 value 不能为 null 主要是为了避免二义性
1. 尽量使用这些原子性的复合操作方法（如 `putIfAbsent`、`compute`、`computeIfAbsent` 、`computeIfPresent`、`merge`）来保证原子性

# [Java集合使用注意事项总结](https://javaguide.cn/java/collection/java-collection-precautions-for-use.html)

# [Java并发常见问题总结（上）](https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html)

## [Java 线程和操作系统的线程有啥区别？](https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html#java-%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB)

### 一个 Java 线程对应一个系统内核线程

### 线程状态

1. NEW: 初始状态，线程被创建出来但没有被调用 `start()` 。
2. RUNNABLE: 运行状态，线程被调用了 `start()`等待运行的状态。
3. BLOCKED：阻塞状态，需要等待锁释放。
4. WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。
5. TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。
6. TERMINATED：终止状态，表示该线程已经运行完毕。

### sleep() 方法没有释放锁，而 wait() 方法释放了对象锁 。yield()让出cpu，重新竞争。join()让线程先执行。

### `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容。run()只是一个方法调用不是多线程

### 破解死锁：整体加锁

## [Java并发常见问题总结（中）](https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html)

### java内存模型

### ![jmm](C:\Users\boss\Desktop\note\java\img\jmm.png)

### 并发特性

- 原子性、可见性、有序性

### volatile 

1. 指示 JVM，每次使用它都到主存中进行读取.防止 JVM 的指令重排序
2. `volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。

### synchronized

1. 保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行
2. 使用方式
   1. 修饰实例方法：不同线程进入某个实例代码前要获得当前对象实例的锁 。
   2. 修饰静态方法：不论什么实例，调用这个类的所有锁起来的方法就会竞争同一把锁。
   3. 修饰代码块:synchronized (XXX) 中的对象是谁，锁的粒度就是什么。
3. 尽量不要使用 `synchronized(String a)` 因为 JVM 中，字符串常量池具有缓存功能
4. 锁升级（锁状态的升级是单向的，JVM 不会进行锁降级）
   1. 无锁状态
   2. 偏向锁状态：某个线程第一次获取时在对象的 Mark Word 中记录“偏向的线程 ID”。如果频繁冲突，JVM 可能**禁用偏向**或对该类/该区域做**批量重偏向**。
   3. 轻量级锁状态：第二个线程获取时发现偏向锁不是自己，则开始偏向撤销（Safe Point），若撤销成功后：T1 仍持锁 → 转为轻量级锁。T1 仍持锁 → 退回无锁状态。
      1. 线程栈帧创建Lock Record，并将对象头中的 Mark Word原始对象存进栈帧。
      2.  **CAS** 把对象头（Mark Word）由原值替换成**指向 当前线程的Lock Record 的指针**，成功则锁竞争成功，否则自旋等待。

   4. 重量级锁状态：轻量级锁自旋失败，则开始锁膨胀。
      1. JVM 创建或获得一个 `ObjectMonitor`（Monitor）实例。
      2. 将对象头（Mark Word）替换为指向该 Monitor 的指针（标志位表示重量级锁）。
      3. 将等待竞争的线程放入 Monitor 的 **entry list**（或等待队列）；被阻塞的线程会被 **park**（操作系统/ VM 层挂起）。
      4. 所有后续关于该对象的 `monitorenter/monitorexit` 都由 Monitor 来管理（包含 owner、递归计数、wait/notify 语义等）。


### volatile 和 synchronized

1. `volatile` 看得见，改不对； `synchronized` 看得见，也改得对。

### 乐观锁、悲观锁

1. 悲观锁：用于写较多的情况
   1. synchronized和ReentrantLock
2. 乐观锁：用于写较少的情况
   1. AtomicInteger、LongAdder（性能更好，占用内存更多）
   2. 一般会使用版本号机制或 CAS 算法实现
      1. `Unsafe`类提供了`compareAndSwapObject`、`compareAndSwapInt`、`compareAndSwapLong`方法来实现的对`Object`、`int`、`long`类型的 CAS 操作
      2. CAS算法会碰到ABA问题

###  公平锁、非公平锁

1. 公平锁
   1. 先到先得锁
2. 非公平锁
   1. 随机得锁

### 可重入锁

​	获得锁得对象可以一直重新获得锁

### 中断锁和不可中断锁

	1. 可中断锁:拿到锁执行，没拿到就继续执行其他代码`ReentrantLock`
	1. 不可中断锁：拿到锁执行，没拿到就等待`synchronized`

## ReentrantReadWriteLock不怎么用

# Java并发常见问题总结（下）

## ThreadLocal

1. 线程的私有变量
2. 每个访问该变量的线程都会拥有一个独立的副本。`get()` 方法获取自己线程的本地副本，或通过 `set()` 方法修改该副本的值
3. 具体数据存储在Thread中的ThreadLocal.ThreadLocalMap中，get是这个map的get方法，多个的换key是对应的ThrealLocal对象
4. 内存泄漏风险：ThreadLocal实例没有被强引用（local=null），线程存活（线程池中）.则ThreadLocalMap中的value值会泄漏。**尽量手动remove对象**
5. set时hash冲突时向后查找。如果向后查找是有key被清理的情况，则进行**TODO:探测式清理**。
6. get时hash不一致向后查找。

### InheritableThreadLocal

1. 创建子线程时，令子线程继承父线程中的 ThreadLocal 值.无法支持线程池场景下的 `ThreadLocal` 值传递。

### TransmittableThreadLocal

1. 在线程池的场景下支持 `ThreadLocal` 值传递

## 线程池

### ThreadPoolExecutor

1. 配置

   - corePoolSize：任务队列未达到队列容量时，最大可以同时运行的线程数量。

   - maximumPoolSize：任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。

   - workQueue：新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。

   - keepAliveTime：当线程池中的线程数量大于 `corePoolSize` ，即有非核心线程（线程池中核心线程以外的线程）时，这些非核心线程空闲后不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销毁。

   - unit：`keepAliveTime` 参数的时间单位。

   - handler：拒绝策略
     - `ThreadPoolExecutor.AbortPolicy`：抛出 `RejectedExecutionException`来拒绝新任务的处理。
     - `ThreadPoolExecutor.CallerRunsPolicy`：调用执行者自己的线程运行任务，也就是直接在调用`execute`方法的线程中运行(`run`)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。**严重影响主线程执行**
     - `ThreadPoolExecutor.DiscardPolicy`：不处理新任务，直接丢弃掉。
     - `ThreadPoolExecutor.DiscardOldestPolicy`：此策略将丢弃最早的未处理的任务请求。

   - allowCoreThreadTimeOut：等待的时间超过了 `keepAliveTime`回收销毁核心线程

2. 预热

   - `prestartCoreThread()`:启动一个线程，等待任务，如果已达到核心线程数，这个方法返回 false，否则返回 true；

   - `prestartAllCoreThreads()`:启动所有的核心线程，并返回启动成功的核心线程数。

3. 异常

   1. **使用`execute()`提交任务**：未捕获异常导致线程终止，线程池创建新线程替代
   2. **使用`submit()`提交任务**：异常被封装在`Future`中，线程继续复用。

4. 关闭
   1. **`shutdown（）`** :关闭线程池，线程池的状态变为 `SHUTDOWN`。不再接受新任务了，但是队列里的任务得执行完毕。
   2. **`shutdownNow（）`** :关闭线程池，线程池的状态变为 `STOP`。终止当前正在运行的任务，停止处理排队的任务并返回正在等待执行的 List。
   3. awaitTermination()：等待线程池关闭完成

5. 线程池大小：N是CPU核心数

   1. CPU 密集型任务：(N)
   2. I/O 密集型任务：(2N)

## Future

## CompletableFuture

- 必须一个独立的线程池

- 具体方法
  1. `CompletableFuture.allOf()`: 合并等待多个任务的执行结果
  2. `thenRunAsync`: 在当前完成后异步执行
  3. `whenComplete`：任务完成时触发回调函数
  4. `exceptionally`:处理异常并重新抛出
  5. `handle`:处理正常的返回结果和异常，并返回一个新的结果
  6. supplyAsync()：有返回运行
  7. runAsync():无返回运行
  8. `thenApply()`：返回结果的流式执行
  9. `thenAccept()`：不返回结果的流式执行
  10. `thenRun()`: 不返回结果的流式执行
  11. `whenComplete()`: 完成后执行函数并返回一个新对象
  12. isDone(): 查看任务是否完成
  13. complete(): 设置任务状态位已完成
  14. completeExceptionally(): 直接响应指定异常
  15. thenCompose(): 调用对象执行完成后执行传入对象
  16. thenCombine(): 调用对象和传入对象并行执行，

## AQS

- CLH 变体队列是一个由Node组成双向队列
- 自旋 + 阻塞
- FIFO 线程等待/等待队列
- 实现
  - ReentrantLock
    - 可重入锁
    - 等待可中断 ：阻塞等待的过程中，如果其他线程中断当前线程 `interrupt()` ，就会抛出 `InterruptedException` 异常，可以捕获该异常，做一些处理操作
    - 可实现公平锁 
    - 可实现选择性通知
    - 支持超时 
  - CountDownLatch
    - 计数减到0
  - Semaphore
    - 统计同时到达某个数字
    - 模式
      - 公平
      - 非公平
  - CyclicBarrier 
    - 类似于CountDownLatch 
    - 基于ReentrantLock

## Java 常见并发容器总结

- **`ConcurrentHashMap`** : 线程安全的 `HashMap`
- **`CopyOnWriteArrayList`** : 线程安全的 `List`，在读多写少的场合性能非常好，远远好于 `Vector`。基于Copy-On-Write实现，修改（ReentrantLock保证）时提供副本修改，然后使用副本。
- **`ConcurrentLinkedQueue`** : **高效的并发队列**，使用链表实现。可以看做一个线程安全的 `LinkedList`，这是一个非阻塞队列。CAS 非阻塞算法来实现线程安全.
- **`BlockingQueue`** : 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。
  - ArrayBlockingQueue
    - 将元素放入满容量队列将导致操作阻塞;从空队列中取元素会阻塞。
  - LinkedBlockingQueue
    - FIFO
  - PriorityBlockingQueue
    - put 方法不会 block，take 会block
- **`ConcurrentSkipListMap`** : 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。

## Atomic 原子类

- 基于CAS

- 实现

  - `AtomicInteger`：整型原子类

  - `AtomicLong`：长整型原子类

  - `AtomicBoolean`：布尔型原子类

  - `AtomicIntegerArray`：整型数组原子类

  - `AtomicLongArray`：长整型数组原子类

  - `AtomicReferenceArray`：引用类型数组原子类

  - `AtomicReference`：引用类型原子类

  - `AtomicMarkableReference`：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来。

  - `AtomicStampedReference`：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。

  - `AtomicIntegerFieldUpdater`:原子更新整型字段的更新器

  - `AtomicLongFieldUpdater`：原子更新长整型字段的更新器

  - `AtomicReferenceFieldUpdater`：原子更新引用类型里的字段




# [Java NIO 核心知识总结](https://javaguide.cn/java/io/nio-basis.html)

- Buffer
  - 容量（`capacity`）：`Buffer`可以存储的最大数据量，`Buffer`创建时设置且不可改变；
  - 界限（`limit`）：`Buffer` 中可以读/写数据的边界。写模式下，`limit` 代表最多能写入的数据，一般等于 `capacity`（可以通过`limit(int newLimit)`方法设置）；读模式下，`limit` 等于 Buffer 中实际写入的数据大小。
  - 位置（`position`）：下一个可以被读写的数据的位置（索引）。从写操作模式到读操作模式切换的时候（flip），`position` 都会归零，这样就可以从头开始读写了。
  - 标记（`mark`）：`Buffer`允许将位置直接定位到该标记处，这是一个可选属性；
- Channel
  - `FileChannel`：文件访问通道；
  - `SocketChannel`、`ServerSocketChannel`：TCP 通信通道；
  - `DatagramChannel`：UDP 通信通道；
- Selector
  - 监听事件
    - `SelectionKey.OP_ACCEPT`：表示通道接受连接的事件，这通常用于 `ServerSocketChannel`。
    - `SelectionKey.OP_CONNECT`：表示通道完成连接的事件，这通常用于 `SocketChannel`。
    - `SelectionKey.OP_READ`：表示通道准备好进行读取的事件，即有数据可读。
    - `SelectionKey.OP_WRITE`：表示通道准备好进行写入的事件，即可以写入数据。
  - NIO 零拷贝(超高性能)
    - MappedByteBuffer 是 NIO 基于内存映射（mmap）这种零拷⻉⽅式的提供的⼀种实现
    - FileChannel 的transferTo()/transferFrom()是 NIO 基于发送文件（sendfile）这种零拷贝方式的提供的一种实现

# Java内存区域详解（重点）

- 程序计数器
- 虚拟机栈
  - 栈帧
    - 局部变量表
    - 操作数栈
    - 动态链接
    - 方法返回地址
- 本地方法栈
- 堆
  - 新生代内存(Young Generation)
  - 老生代(Old Generation)
- 方法区
  - 类信息
  - 字段信息
  - 方法信息
  - 常量
  - 静态变量
  - 即时编译器编译后的代码缓存等数据
  - 运行时常量池
    - Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 **常量池表(Constant Pool Table)** 。
- 直接内存 (非运行时数据区的一部分)
  - NIO直接使用 Native 函数库直接分配堆外内存。避免在 Java 堆和 Native 堆之间来回复制数据
- [对象的创建](https://javaguide.cn/java/jvm/memory-area.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA)

# [JDK监控和故障处理工具总结](https://javaguide.cn/java/jvm/jdk-monitoring-and-troubleshooting-tools.html)

- **`jps`** (JVM Process Status）: 类似 UNIX 的 `ps` 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；
- **`jstat`**（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;
- **`jinfo`** (Configuration Info for Java) : Configuration Info for Java,显示虚拟机配置信息;
- **`jmap`** (Memory Map for Java) : 生成堆转储快照;
- **`jstack`** (Stack Trace for Java) : 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。
  - `jstat -class vmid`：显示 ClassLoader 的相关信息；
  - `jstat -compiler vmid`：显示 JIT 编译的相关信息；
  - `jstat -gc vmid`：显示与 GC 相关的堆信息；
  - `jstat -gccapacity vmid`：显示各个代的容量及使用情况；
  - `jstat -gcnew vmid`：显示新生代信息；
  - `jstat -gcnewcapcacity vmid`：显示新生代大小与使用情况；
  - `jstat -gcold vmid`：显示老年代和永久代的行为统计，从 jdk1.8 开始,该选项仅表示老年代，因为永久代被移除了；
  - `jstat -gcoldcapacity vmid`：显示老年代的大小；
  - `jstat -gcpermcapacity vmid`：显示永久代大小，从 jdk1.8 开始,该选项不存在了，因为永久代被移除了；
  - `jstat -gcutil vmid`：显示垃圾收集信息；
- JConsole
- Visual VM
- MAT
  - 堆
    - **Shallow Heap**（浅堆）：对象本身占用的内存大小（不包括引用的对象）
    - **Retained Heap**（保留堆）：如果这个对象被 GC 回收后，**能一同被回收的所有对象的总和**

- Arthas

# LINUX

- Linux 文件系统
  - 硬盘以扇区 (Sector) 为最小物理存储单位，而操作系统和文件系统以块 (Block) 为单位进行读写，块由多个扇区组成。文件数据存储在这些块中。现代硬盘扇区通常为 4KB，与一些常见块大小相同，但操作系统也支持更大的块大小，以提升大文件读写性能。文件元信息（例如权限、大小、修改时间以及数据块位置）存储在 inode（索引节点）中。每个文件都有唯一的 inode。inode 本身不存储文件数据，而是存储指向数据块的指针，操作系统通过这些指针找到并读取文件数据。 固态硬盘 (SSD) 虽然没有物理扇区，但使用逻辑块，其概念与传统硬盘的块类似。
  - inode 是一种固定大小的数据结构，其大小在文件系统创建时就确定了，并且在文件的生命周期内保持不变。
- 硬链接和软连接
  - 只有删除了源文件和所有对应的硬链接文件，该文件才会被真正删除。
  - 软连接类似于 Windows 系统中的快捷方式。
  - 软链接可以跨越文件系统。
- 文件类型
  - **普通文件（-）**：用于存储信息和数据， Linux 用户可以根据访问权限对普通文件进行查看、更改和删除。比如：图片、声音、PDF、text、视频、源代码等等。
  - **目录文件（d，directory file）**：目录也是文件的一种，用于表示和管理系统中的文件，目录文件中包含一些文件名和子目录名。打开目录事实上就是打开目录文件。
  - **符号链接文件（l，symbolic link）**：保留了指向文件的地址而不是文件本身。
  - **字符设备（c，char）**：用来访问字符设备比如键盘。
  - **设备文件（b，block）**：用来访问块设备比如硬盘、软盘。
  - **管道文件(p，pipe)** : 一种特殊类型的文件，用于进程之间的通信。
  - **套接字文件(s，socket)**：用于进程间的网络通信，也可以用于本机之间的非网络通信。
- 常用命令
  - cd
  - ls
  - find
  - ln
  - scp
  - ftp
  - chmod
  - htop
  - top
  - free
  - df
  - du
  - export: 获取所有环境变量。也可以修改，但是关闭shell后失效。
- 环境变量
  - 用户级别环境变量 : `~/.bashrc`、`~/.bash_profile`。
  - 系统级别环境变量 : `/etc/bashrc`、`/etc/environment`、`/etc/profile`、`/etc/profile.d`。

# 数据库

## SQL

### 数据定义语言（DDL）

### 数据操纵语言（DML）

- CRUD

### 事务控制语言（TCL）

### 数据控制语言（DCL）

## 优化
- 某些字符串可以转换成数字类型存储，比如可以将 IP 地址转换成整型数据。
- 对于非负型的数据 (如自增 ID、整型 IP、年龄) 来说，要优先使用无符号整型来存储。
- 小数值类型（比如年龄、状态表示如 0/1）优先使用 TINYINT 类型。
-  建议把 BLOB 或是 TEXT 列分离到单独的扩展表中。
- 一定不要用字符串存储日期
- 同财务相关的金额类数据必须使用 decimal 类型
- 限制每张表上的索引数量，建议单张表索引不超过 5 个
- 禁止使用全文索引
- **禁止给表中的每一列都建立单独的索引**
- **每个 InnoDB 表必须有个主键**
- **区分度最高的列放在联合索引的最左侧**：这是最重要的原则。区分度越高，通过索引筛选出的数据就越少，I/O 操作也就越少。计算区分度的方法是 count(distinct column) / count(*)。最频繁使用的列放在联合索引的左侧：这符合最左前缀匹配原则。将最常用的查询条件列放在最左侧，可以最大程度地利用索引。
- 字段长度：字段长度对联合索引非叶子节点的影响很小，因为它存储了所有联合索引字段的值。字段长度主要影响主键和包含在其他索引中的字段的存储空间，以及这些索引的叶子节点的大小。因此，在选择联合索引列的顺序时，字段长度的优先级最低。对于主键和包含在其他索引中的字段，选择较短的字段长度可以节省存储空间和提高 I/O 性能。
- **禁止使用 SELECT * 必须使用 SELECT <字段列表> 查询**
- **避免数据类型的隐式转换:隐式转换会导致索引失效**
- 避免使用子查询，可以把子查询优化为 join 操作

### 索引失效的场景

1. 对索引列进行类型转换（字母转换成0，数字转为对应数字）
2. like
3. 复合索引未遵守最左前缀原则
4. 使用 NOT、!=、<>、IS NULL、IS NOT NULL 等条件
5. 范围查询影响后续列使用
6. 查询排序需要回表时。ORDER BY / GROUP BY 与索引不匹配

### 约束索引和非约束索引

- 约束索引

  - primary key：不允许空值

  - unique key

- 非约束索引

  - 普通索引
  - 唯一索引
  - 组合索引
  - 全文索引

### 聚簇索引和非聚簇索引

 - 聚簇索引
   - 数据和索引放在一起
   - 主键是聚簇索引。没有主键则使用unique key。都没有则是隐式生成的 row-id。
     - 聚簇索引使用有序自增可以提高性能。
 - 非聚簇索引

### 回表

- 最左前缀原则
- 查询索引字段可以减少回表

### 分库分表

- 方式

  - 水平：数据分布到多张表

  - 垂直：字段分布到多张表

- 分布式主键
  - 引入中间件：每次请求一批的id

### 事务

- ACID
  - A原子性:Undo log
  - C一致性
  - I 隔离性：MVCC多版本并发控制
  - D持久性:内存+redo log
    - redo log记录标记为prepare状态
    - 数据写入文件并写入bin log

### 主从同步原理

- 通过binlog同步

## Redis 

### redis 集群方案

- 主从
  - 主从数据复制
    - 全量复制：主节点发送RDB文件。从节点清空数据，从rdb中恢复
    - 部分复制
      - 主从节点都维护一个偏移量，对比偏移量判断是否一致
      - 主节点维护一个命令FIFO缓冲区，超出缓冲区的话则启动全量复制
      - 服务器运行id，如果id不一致则全量同步
  - 主从可以进行联级主从：一主二从，二从可以继续有四个从节点
- 哨兵
  - 主从模式加哨兵sentinel集群
  - 可以做哨兵集群
    - 至少三个实例 
  - 本质还是主从，不能支持超高的并发
  - 功能
    - 集群监控：
    - 消息通知：
    - 故障转移：大部分哨兵同意并做分布式选举出主节点
    - 配置中心：
- redis cluster
  - 服务端分片。
  - 至少三个节点（推荐奇数个节点），防止选举失败。
  - 数据槽位：16384槽位均分到所有redis节点中
  - 数据分布：对key做hash，然后对16384取模
  - 每个redis分片可以用主从架构
  - 如果key不在请求节点，则会转发指令
  - 扩容缩容时按槽位进行重新划分 
  - 需要开放两个端口，一个提供服务，一个提供节点间通信。
    - cluster-node-timeout支持断连时长
- redis sharding
  - 客户端分片
  - 互相之间没有感知

### **5 种基础数据类型**：

- String（字符串）
- List（列表）：
  - ziplist：元素少。
  - quicklist：元素多。多个zipList组成，节点之间是双线链表。

- Set（集合）
  - intset（整数集合）：当 Set 元素都是整数且数量较少时使用。通过二分查找实现快速查询
  - hashtable（哈希表）：当元素非整数或元素多时使用。
    - 扩容时渐进式 rehash
  
- Hash（散列）
  - ziplist（压缩列表）
  - hashtable（哈希表）

- Zset（有序集合）
  - ziplist：少量元素
  - skiplist + hashtable

- **3 种特殊数据类型**：
  - HyperLogLog（基数统计）
  - Bitmap （位图）
    - 布隆过滤器
  - Geospatial (地理位置)。

### Redis Module

- Redis 从 4.0 版本开始，支持通过 Module 来扩展其功能以满足特殊的需求。

### 持久化机制

- 快照（snapshotting，RDB）
  - save：阻塞主线程
  - bgsave
  - save m n: m秒有n个键修改，则进行save
  - flushall:清空所有内存数据，并保存为dump.rdb

- 追加文件（append-only file, AOF）
  - AOF重写， 压缩AOF文件
  - 同步策略
    - 每秒同步
    - 每次修改同步
    - 不同步
- RDB 和 AOF 的混合持久化(Redis 4.0 新增)

### Rredis线程

- Redis 通过 多个Socket、IO 多路复用程序、文件事件分派器、事件处理器 来监听来自客户端的大量连接
- 文件事件处理器（file event handler）主要是包含 4 个部分：
  - 多个 socket（客户端连接）
  - IO 多路复用程序（支持多个客户端连接的关键）
  - 文件事件分派器（将 socket 关联到相应的事件处理器）
  - 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）
- 后台线程
  - 通过 `bio_close_file` 后台线程来释放 AOF / RDB 等过程中产生的临时文件资源。
  - 通过 `bio_aof_fsync` 后台线程调用 `fsync` 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘（AOF 文件）。
  - 通过 `bio_lazy_free` 后台线程释放大对象（已删除）占用的内存空间.

### key过期策略

1. Redis 的定期删除过程是随机的（周期性地随机从设置了过期时间的 key 中抽查一批）
   1. 执行时间已经超过了阈值，那么就中断这一次定期删除循环，以避免使用过多的 CPU 时间。
   2. 如果过期的 key 比例超过一个比例，就会重复执行删除流程。如果过期的 key 比例低于这个比例，就会中断这一次定期删除循环。
2. 惰性过期
   1. 查询到key时判断是否过期，过期则删除


### Redis 内存淘汰策略

1. **volatile-lru（least recently used）**：从已设置过期时间的数据集（`server.db[i].expires`）中挑选最近最少使用的数据淘汰。
2. **volatile-ttl**：从已设置过期时间的数据集（`server.db[i].expires`）中挑选将要过期的数据淘汰。
3. **volatile-random**：从已设置过期时间的数据集（`server.db[i].expires`）中任意选择数据淘汰。
4. **volatile-lfu（least frequently used）**：从已设置过期时间的数据集（`server.db[i].expires`）中挑选最不经常使用的数据淘汰。
5. **allkeys-random**：从数据集（`server.db[i].dict`）中任意选择数据淘汰。
6. **allkeys-lfu（least frequently used）**：从数据集（`server.db[i].dict`）中移除最不经常使用的数据淘汰。
7. **allkeys-lru（least recently used）**：从数据集（`server.db[i].dict`）中移除最近最少使用的数据淘汰。
8. **no-eviction**（默认内存淘汰策略）：禁止驱逐数据，当内存不足以容纳新写入数据时，新写入操作会报错。

### Redis 事务

- 鸡肋，中间报错不会回滚

### Redis性能优化

- 使用批量操作减少网络传输
- 给 key 设置随机过期时间。
- **开启 lazy free 机制**：修改 `redis.conf` 配置文件，将 `lazyfree-lazy-expire` 参数设置为 `yes`，即可开启 lazy free 机制。开启 lazy free 机制后，Redis 会在后台异步删除过期的 key，不会阻塞主线程的运行，从而降低对 Redis 性能的影响。
- 避免big key
- 避免删除big key
  - 使用unlink或ASYNC

- 关注hot key
  - 解决方式
    - **读写分离**：主节点处理写请求，从节点处理读请求。
    - **使用 Redis Cluster**：将热点数据分散存储在多个 Redis 节点上。
    - **二级缓存**：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中（可以用 Caffeine）。
- 缓存穿透（无效的key，去查询数据库也没有数据）
  - 缓存无效 key
  - 布隆过滤器
  - 接口限流
- 缓存击穿：某个hotkey过期
  - 提前预热
  - 加锁（只有一个请求去数据库找）
- 缓存雪崩（大量缓存同时失效）
  - 设置随机失效时间
  - 提前预热
  - 持久缓存策略
- 保证缓存数据库一致
  - 读操作
    1. 先尝试从缓存读取数据。
    2. 如果缓存命中，直接返回数据。
    3. -如果缓存未命中，从数据库查询数据，将查到的数据放入缓存并返回数据。
  - 写操作（延时双删）
    1. 删除缓存
    2. 更新数据库。
    3. 防止更新时有读取请求，过一段时间后再次删除缓存

## Elasticsearch

- 集群与节点（Cluster & Node）
  - discovery.type=single-node: 集群为开发模式，不对集群进行配置项检查。
  - 不配置discovery.type则会检查集群配置
    - 堆大小检查
    - 文件描述符检查
    - 内存锁检查
    - 最大线程数检查
    - 最大文件大小检查

- 查询类型
  - 词项查询
    - terms精确查询：不进行分词
    - range范围查询
    - exists：字段存在查询
    - prefix：前缀查询
    - wildcard：通配符（ *和？）
    - regexp：正则查询
    - ids：文档id查询

  - 全文的查询
    - match：会进行分词
    - multi_match
    - match_phrase：分词后顺序不变
    - match_phrase_prefix: 且是开头

  - 复合查询
    - bool
      - must
      - must_not
      - filter：不计算结果的相关度
      - should：多个条件满足minimum_should_match个才通过
        - minimum_should_match：should至少满足几个

- 索引与文档（Index & Document）
  - Index
  - Document
  - Field
- 倒排索引
  - 通过词->文档列表。
  - 压缩算法
    - FOR
    - RBM
- 分析器
  - 处理过程
    - **字符过滤（char filter）**：预处理（如去除 HTML 标签）
    - **分词器（tokenizer）**：把文本分割为词（tokens）
    - **词元过滤器（token filter）**：统一大小写、去除停用词、词干还原等
- mapping
  - 自动映射和手动映射

  - 类型
    - text
    - keywords
      - keyword: 不对数据进行分词
      - constatn_keyword
      - wildcard

    - integer / float / double
    - boolean
    - dates:
      - date
      - date_nanos

    - text：全文检索
    - object：单个json
    - nested：json数组

- 分片和副本
  - Shard=Lucene 索引
    - Primary Shard
    - Replica Shard
- 写入查询
  - 写入查询流程
    - 写入流程
      - 客户端发送文档到任意节点（协调节点）
      - 计算文档的路由（由 _id 哈希决定目标主分片）
      - 写入主分片
      - 同步到副本分片
      - 任一副本分片返回成功，则响应成功（写入成功）

    - 查询流程
      - 协调节点接收请求
      - 将查询请求广播给所有分片（主或副本）
      - 每个分片执行查询并返回结果
      - 协调节点汇总、排序、分页
      - 返回最终结果

  - 写入落盘流程
    - 写入Translog文件（每次请求后写入磁盘）
    - 写入内存缓冲区
    - **Refresh**（默认每 **1 秒** 一次。）将内存缓冲区中的所有文档写入新创建的 OS cache 和 Lucene segment。此时可查。
    - **Flush** （默认每 **30 分钟** 一次）持久化segment并清理 Translog

- 近实时（Near Real-Time, NRT）
  - 原因是写入落盘流程

- 聚合（Aggregation）

## MYBATIS

### 分层架构

1. 接口层
   1. SqlSession
   2. Mapper 接口的 API（推荐）
      1. JDK 动态代理或CGLib代理 Mapper 接口，实际上调用的是 `MapperProxy` 的 `invoke` 
2. 核心层
   1. SqlSessionFactoryBuilder：根据XMLConfigBuilder、XMLMapperBuilder读取的Configuration生成SqlSessionFactory
   2. Executor（执行器）
      - **SimpleExecutor**：每次执行都会创建新的 `Statement` 对象；
      - **ReuseExecutor**：重用 `Statement`；
      - **BatchExecutor**：批量执行 SQL，提高插入/更新性能。
      - **CachingExecutor**：用于二级缓存
   3. ParameterHandler
   4. ResultSetHandler
   5. StatementHandler
      1. PreparedStatementHandler
      2. SimpleStatementHandler
      3. CallableStatementHandler
3. 基础层
   1. datasource模块
      1. UnpooledDataSourceFactory：无连接池，每次都创建
      2. PooledDataSourceFactory：mybatis自带的简易连接池
      3. JndiDataSourceFactory：jndi查找可用连接池
   2. transaction模块
      1. JdbcTransaction：一个SqlSession对应一个事务
      2. ManagedTransaction：由外部管理，比如spring
   3. cache模块
   4. reflection模块
      1. 结果集映射、参数设置等都重度依赖此模块来动态地操作 POJO
   5. typeHandler模块
      1. 在 PreparedStatement 中为参数设置值（Java Type -> JDBC Type）。
      2. 从 ResultSet 中获取结果并转换为 Java 对象（JDBC Type -> Java Type）。
   6. logging模块
      1. 对主流的日志框架（如 SLF4J, Log4j2, Logback, Commons Logging, JDK Logging 等）进行桥接和适配
   7. io模块

### 缓存模块

- 一级缓存
  - sqlseesion共享，在executor中有一个cache对象。
- 二级缓存
  - 在sqlsession关闭或提交后，才缓存到二级缓存。
  - 同一namespace下共享，可使用不同的缓存介质。
- 缓存失效。任何更新操作，当前命名空间下的一二级缓存都会失效。
  - @CacheNamespaceRef/ref-cache：多个namespace共享二级缓存。
  - mapper xml中配置useCache：查询结果是否存入二级缓存
  - mapper xml中配置flushCache：**高危**更新语句执行时是否清空缓存。
- 缓存
  - \<cache>和@CacheNamespace配置
    - eviction ：缓存满时的淘汰策略
      - LRU：最少使用
      - FIFO：先进先出
      - SOFT：软引用
      - WEAK：弱引用
    - flushInterval ：缓存刷新间隔
    - size ：最大缓存数量
    - readOnly：缓存对象是否只读
    - type：缓存的实现
      - EhcacheCache、RedisCache、MyCustomCache

### 插件机制（拦截器）

- @Signature
  - 用法：使用@Signature并实现Interceptor。相当于使用AOP的@Arround，需要执行invocation.proceed()
    - @Signature
      - type：指定要拦截的组件类型
        - Executor
        - ParameterHandler
        - ResultSetHandler
        - StatementHandler

      - method：拦截的方法
      - args：拦截的方法参数

- @Intercepts

```java
@Intercepts({
    @Signature(
        type = ResultSetHandler.class,
        method = "handleResultSets",
        args = {Statement.class}
    )
})
```



### 标签

- resultMap中的层级嵌套
  - association：一对一
  - collection：一对多

### 大数据量查询

- options中使用fetchSize
- 使用流式查询

### SPRING BOOT

- 复合注解
  - @ComponentScan
  - @EnableAutoConfiguration
  - @SpringBootConfiguration
- spring.factories: 一种SPI的实现。会将文件中的类加载到spring容器中

- 配置加载顺序
  1. 命令行
  2. java系统变量
  3. 操作系统环境变量
  4. 外部配置文件
  5. 内部默认配置文件
  6. 内部环境配置文件
  7. 环境配置文件

### SPRING MYBATIS

- spring 使用 `SqlSessionTemplate` 来代理 `SqlSession`

#### 事务

- 事务管理器 DataSourceTransactionManager 集成。
  - 将sqlsession存入ThreadLocal中
- 事务执行链路
  - 拦截器`TransactionInterceptor`拦截方法调用
  - 根据事务传播机制判断是否开启新事务。事务管理器`PlatformTransactionManager`从连接池获取一个新`connection`并这个连接绑定到当前线程的ThreadLocal并调用`connection.setAutoCommit(false)`
  - 然后进入mybatis的执行过程
    - Mapper 接口方法调用
    - MapperProxy 代理拦截
    - 根据方法名查找 MappedStatement
      - sql的相关信息

    - 优先使用ThreadLocal中的SqlSession，否则创建
    - Executor 执行查询
    - StatementHandler 创建 Statement
    - ParameterHandler 设置参数
    - Statement 执行 SQL
    - ResultSetHandler 处理结果集

### 事务注解

- @Transactional(**transactionManager = "txManagerA"**)。只能单独管理一个数据库的事务。
- 多数据源事务手动事务、JTA 分布式事务、分布式事务

#### 事务失效

- 没有经过spring 代理
- private或final方法（cglib代理会失效，在没有实现接口时使用cglib）
- 多线程

#### 传播机制

1. REQUIRED：存在则加入；没有则创建。
2. REQUIRES_NEW：创建一个新事物，并暂停当前事务。
3. SUPPORTS：有则加入，没有则非事务运行。
4. NOT_SUPPORTED：非事务执行，并暂停当前事务
5. NEVER：要求不存在事务。否则就抛出异常
6. NESTED：与 REQUIRED 一样。但是独立执行。
7. MANDATORY：存在则加入；否则就抛出异常

#### 隔离级别

1. **`TransactionDefinition.ISOLATION_DEFAULT`** :使用后端数据库默认的隔离级别
2. **`TransactionDefinition.ISOLATION_READ_UNCOMMITTED`** :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更
3. **`TransactionDefinition.ISOLATION_READ_COMMITTED`** : 允许读取并发事务已经提交的数据
4. **`TransactionDefinition.ISOLATION_REPEATABLE_READ`** : 对同一字段的多次读取结果都是一致的，
5. **`TransactionDefinition.ISOLATION_SERIALIZABLE`** : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。但是这将严重影响程序的性能。通常情况下也不会用到该级别。

## SPRING

#### 基础

- bean不是线程安全的

### Bean 的生命周期

![spring-bean-lifestyle](img\spring-bean-lifestyle.png)

#### spring启动流程

1. 扫描所有BeanDefinition对象存入Map
2. 获取BeanFactory并找出所有非懒加载的Bean进行创建。
3. 发布容器启动事件

### Bean 的作用域

-  **singleton** : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。

- **prototype** : 每次获取都会创建一个新的 bean 实例。也就是说，连续 `getBean()` 两次，得到的是不同的 Bean 实例。

- **request** （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。

- **session** （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。

- **application/global-session** （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。

- **websocket** （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。


#### AOP

- SPRING AOP：JDK动态代理或CGLIB
- AspectJ：AspectJ编译器

### SPRING MVC

#### 流程说明（重要）

1. 客户端（浏览器）发送请求， `DispatcherServlet`拦截请求。
2. `DispatcherServlet` 根据请求信息调用 `HandlerMapping` 。`HandlerMapping` 根据 URL 去匹配查找能处理的 `HandlerAdapter`（也就是我们平常说的 `Controller` 控制器） 
3. `DispatcherServlet` 调用 `HandlerAdapter`适配器执行 `Handler` 。
4. `Handler` 完成对用户请求的处理后，会返回一个 `ModelAndView` 对象给`DispatcherServlet`，`ModelAndView` 顾名思义，包含了数据模型以及相应的视图的信息。`Model` 是返回的数据对象，`View` 是个逻辑上的 `View`。
5. `ViewResolver` 会根据逻辑 `View` 查找实际的 `View`。
6. `DispaterServlet` 把返回的 `Model` 传给 `View`（视图渲染）。
7. 把 `View` 返回给请求者（浏览器）

#### 拦截器HandlerInterceptor 

- preHandle
- postHandle
- afterCompletion

### Filter 过滤器

- doFilter：执行下一个过滤器
- @Order(1)：过滤器顺序
- @WebFilter(urlPatterns = "/*")：要过滤的链接

### spring创建bean的循环依赖

- 三级缓存
  - **一级缓存（singletonObjects）**：存放最终形态的 Bean（已经实例化、属性填充、初始化），单例池，为“Spring 的单例属性”⽽⽣。一般情况我们获取 Bean 都是从这里获取的，但是并不是所有的 Bean 都在单例池里面，例如原型 Bean 就不在里面。
  - **二级缓存（earlySingletonObjects）**：存放过渡 Bean（半成品，尚未属性填充），也就是三级缓存中`ObjectFactory`产生的对象，与三级缓存配合使用的，可以防止 AOP 的情况下，每次调用`ObjectFactory#getObject()`都是会产生新的代理对象的。
  - **三级缓存（singletonFactories）**：存放`ObjectFactory`，`ObjectFactory`的`getObject()`方法（最终调用的是`getEarlyBeanReference()`方法）可以生成原始 Bean 对象或者代理对象（如果 Bean 被 AOP 切面代理）。三级缓存只会对单例 Bean 生效。
- 过程
  - 先去 **一级缓存 `singletonObjects`** 中获取，存在就返回；
  - 如果不存在或者对象正在创建中，于是去 **二级缓存 `earlySingletonObjects`** 中获取；
  - 如果还没有获取到，就去 **三级缓存 `singletonFactories`** 中获取，通过执行 `ObjectFacotry` 的 `getObject()` 就可以获取该对象，获取成功之后，从三级缓存移除，并将该对象加入到二级缓存中

### 常用注解

1. @SpringBootApplication
2. @Autowired
3. @Resource(name="beanName")
4. @Scope("scopeName")
5. @Component
6. @Repository
7. @Service
8. @Controller
9. @RestController
10. @Configuration
11. @Value("${property.key}")

## DOCKER

- **Namespace 与 cgroup**：
  - **Namespace**：隔离进程、网络、PID、用户等。

  - **cgroup**：限制容器的 CPU、内存、I/O 等资源。

- DOCKER File
  - `FROM`：指定基础镜像。
  - `RUN`：在镜像构建过程中执行命令。
  - `COPY` / `ADD`：将文件从宿主机复制到镜像中。
  - `WORKDIR`：设置工作目录。
  - `EXPOSE`：声明容器运行时监听的端口。
  - `ENV`：设置环境变量。
  - `CMD`：指定容器启动时默认执行的命令。只有最后一条生效。如果有ENTRYPOINT则作为ENTRYPOINT的参数
  - `ENTRYPOINT`：配置容器启动时运行的命令，不可被 `docker run` 提供的参数覆盖

- **Docker 的网络模式**
  - **bridge**
  - **host**

## KUBERNETES

#### 基础

- namespace：项目逻辑隔离

#### 认证方式

- 证书认证
- Bearer Token
- ServiceAccount
- Webhook
- HTTP基本认证

#### kubectl

- kubectl get
- kubectl describe
- kubectl create：创建一个资源，重复会报错。
- kubectl apply：创建一个资源。重复会覆盖。
- kubectl delete
- kubectl edit
- kubectl run
- kubectl expose
- kubectl logs
- kubectl exec
- kubectl port-forward
- kubectl proxy
- kubectl scale
- kubectl cordon
- kubectl drain
- kubectl top
- kubectl uncordon
- kubectl taint
- kubectl explain
- kubectl config

#### pause容器

- 提前为pod中的各个容器准备网络等资源

#### 网络

- pod间
  - 同节点：网桥
  - 跨节点：CNI 插件
    - Overlay 网络：如 Flannel 的 VXLAN 模式、Calico 的 IPIP 模式
    - Underlay 网络：Calico 的 BGP 模式
- pod和service
  - kube-proxy
    - iptables
    - IPVS
  - CoreDNS
- 外部网络与 Service 
  - NodePort
  - LoadBalancer
  - Ingress
- Pod 与外部网络

#### node scheduler

- 过滤
      1. PodFitsResources:剩余资源大于pod请求资源
      2. PodFitsHost：是否指定了node
      3. PodFitsHostPorts：port是否和pod冲突
      4. PodSelectorMatches：label是否匹配
      5. NoDiskConflict：mount的volume是否冲突
- 评分
  - LeastRequestedPriority:CPU和Memory使用率越低
  - BalanceResourceAllocation：CPU和Memory使用率越接近
  - ImageLocalityuPriority：已经有镜像的总占用大小，越大越高

### service

- **ClusterIP**
  - headless：返回所有ip
  - 普通：发给指定ip后kubeproxy转发

- NodePort
- LoadBalancer
- ExternalName

#### 污点类型

- NoSchedule：不影响已经在的
- NoExecute：已经在的会驱逐
- PreferNoSchedule

#### 容忍

- operator
  - Equal：完全匹配，需要填写value和effect
  - Exists：存在容忍，可以不填写value和effect
- value
- effect
- tolerationSeconds

## DDD

- 分层
  - 领域层
  - 基础层
  - 用户接口层
  - 应用层
- 高内聚、低耦合

## Eureka

- 客户端
  - 启动拉取，30秒拉取和发送心跳
- 服务端
  - 自我保护
  - 集群互相注册

### OpenFeign

- **`@FeignClient`**
  - name\value
  - url
  - path
  - configuration：指定配置类
  - fallback / fallbackFactory
- RequestInterceptor ：拦截器实现后请求前会调用
- @SpringQueryMap:将对象转为请求的表单参数
  - 同时需要配置consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE

## hystrix

- 线程隔离
  - **线程池隔离（Thread Pool）**：适用于耗时长的服务调用，调用在独立线程中执行。
  - **信号量隔离（Semaphore）**：适用于耗时短、频繁调用的服务，避免线程切换开销。
- **断路器（Circuit Breaker）机制**
  - **闭合（Closed）**：正常调用
  - **开启（Open）**：调用失败率超过阈值，短时间内拒绝请求
  - **半开（Half-Open）**：允许少量请求尝试恢复服务
- **服务降级（Fallback）**：当服务调用失败、超时或断路器开启时，执行降级逻辑，保证系统可用性。
- 服务熔断：fall-fast

## rocketmq

### 消息类型

- 普通消息
- 顺序消息
- 事务消息

### 主从数据复制

- 同步复制：也叫 “同步双写”，也就是说，**只有消息同步双写到主从节点上时才返回写入成功** 。
- 异步复制：**消息写入主节点之后就直接返回写入成功** 。

### 数据存储

- CommitLog
  - 数据存储文件
  - 顺序写入
  - 支持同步刷盘和异步刷盘
- ConsumeQueue
  - 按topic分	
  - 逻辑索引文件，异步构建。
  - **Commit Log Offset（8字节）**：该条消息在 CommitLog 中的物理偏移量。
  - **Size（4字节）**：消息在 CommitLog 中占用的长度。
  - **Message Tag HashCode（8字节）**：消息 Tag 的哈希值，用于 Tag 过滤。
- IndexFile
  - 存储key的hash槽
  - 链表存储所有key一样的消息
  - 异步构建
  - 结构
    - **Header**：包含一些元信息，如存储的起止时间、起始和结束的物理偏移量等。
    - **Hash Slot（槽位）**：固定数量的槽（默认5百万个），每个槽占 4 字节。
    - **Index Entry（条目）**：存储具体的索引数据，包括：
      - Key Hash：消息 Key 的哈希值。
      - CommitLog Offset：消息物理偏移量。
      - Next Index Offset：解决哈希冲突的指针，指向下一个 Index Entry。
      - Timestamp：消息存储时间与起始时间的差值。

## apollo

1. 更新机制
   1. 长轮询：客户端发起请求。如果没有更新则阻塞，有更新则返回

## arthas

```shell
#查看类的加载信息及实例数量
sc -d <class> 
#查看所有线程状态
thread
#查看 JVM 堆内存使用情况
heap
#查看实时 JVM 资源使用情况（CPU/内存/GC/线程）
dashboard
```



### JDK新特性

#### JDK9

- 模块化系统:可以通过jlink构建较小的jdk包
- G1 成为默认垃圾回收器

#### JDK10

- var
- G1 并行 Full GC

#### JDK11

- ZGC(可伸缩低延迟垃圾收集器)

#### JDK21

- 序列化集合:元素遍历顺序固定
- 分代 ZGC
- 虚拟线程：JVM管理，底层使用一个线程，轻量廉价。

