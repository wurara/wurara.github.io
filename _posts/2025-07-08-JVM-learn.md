---
layout: post
title: java JVM
subtitle: jvm学习笔记
cover-img: /assets/img/path.jpg
thumbnail-img: /assets/img/thumb.png
share-img: /assets/img/path.jpg
tags: [java, JVM]
---


### 内存和gc

1. 类加载过程
   1. 加载
      1. 通过类的全限定名称获取二进制字节流
      2. 将静态存储结构转换为方法区运行时数据结构
      3. 内存中生成Class对象用于数据访问入口
   2. 链接
      1. 验证
         1. 确保class文件不会危害jvm
         2. 文件格式验证、元数据验证、字节码验证、符号引用验证
      2. 准备
         1. 为类变量分配内存并设置初始0值
         2. **常量（final修饰的）就会初始化为对应值**(极大提高性能)
         3. 将符号引用转换为直接引用
      3. 解析
   3. 初始化
      1. 执行类构造器方法<clinit>()
      2. clinit()是收集所有成员变量（类变量和实例变量）的复制动作和静态代码块的语句合并，没有则不生成
      3. 执行init()方法
      4. 优先执行父类的<clinit>()，
      5. 一个类只会被加载一次，只执行一次clinit 
2. 类加载器
   1. 引导类加载器
      1. c/c++实现
      2. 用于加载核心类库，jvm本身的类库
      3. 加载扩展类库加载器和应用程序类加载器
      4. 只加载java、javax、sun开头的
   2. 自定义类加载器
      1. 拓展类加载器
         1. java编写，派生于classloader
         2. 由引导类加载器加载
         3. 从java.ext.dirs或jre/lib/ext中加载，用户的class放进去也会被加载
      2. 系统类加载器
         1. java编写，派生于classloader
         2. 加载classpath或者Java.class.path下的类库
         3. Java应用默认的加载器
         4. ClassLoader.getSystemClassLoader()
      3. 自定义加载器
         1. 隔离加载类
         2. 修改类加载方式
         3. 扩展加载源
         4. 防止源码泄露 
   3. 双亲委派机制
      1. 引导类->拓展类->应用类->自定义类
      2. 避免重复加载、避免核心api被篡改(沙箱安全机制)
   4. 其他
      1. 同一个对象的必要条件：
         1. 完全限定名一致
         2. classloader一致、
      2. 类由用户类加载器时，jvm会将类加载器的引用放在这个类的方法区中。解析其他类的引用时要确保是同一个类加载器。
      3. 主动使用一个类会初始化这个类
         1. 创建实例
         2. 访问静态变量或赋值静态变量
         3. 访问静态方法
         4. 反射
         5. 初始化子类
         6. jvm启动时标记为启动类的
3. 内存
   1. 总体
      1. 方法区、堆整个jvm共用
      2. 本地方法栈、程序计数器、虚拟机栈每个线程私有
      3. RunTime是一个jvm实例
   2. 线程
      1. hotspot中jvm线程就是操作系统本地线程
      2. 守护线程
      3. 普通线程
      4. 系统线程
         1. 虚拟机线程
         2. 周期性任务线程
         3. GC线程
         4. 编译线程
         5. 信号调度线程
   3. 程序计数器
      1. 每个线程一份
      2. 指向当前线程中的当前栈帧中执行的Java方法的JVM执行指令的下一行指令的地址。或者是native方法，则是未指定值。
      3. 控制流指示器、分支、循环、跳转、异常处理、**线程恢复**都需要计数器完成
      4. 唯一一个没有OutOfMemoryError的区域
      5. 指令引擎读取程序寄存器中的地址后执行并
      6. cpu时间片
   4. 虚拟机栈
      1. 基础信息
         1. 一个栈帧对应一个方法
         2. 生命周期与线程一致
         3. 保存局部变量、部分结果与方法的调用和返回
         4. 速度次于程序计数器
         5. JVM只会压栈和出栈，先进后出
         6. 没有垃圾回收
         7. -xss设置最大大小
         8. 栈顶缓存技术：将栈顶元素存入物理cpu寄存器中
      2. 栈的存储
         1. 每个线程有自己的栈，栈里面存着栈帧
         2.  结构
            1. 局部变量表LV
               1. 一个数字数组
               2. 方法的参数
               3. 方法体内在编译器可知的局部变量
               4. 不存在线程安全问题。**栈调优最重要的参数**
               5. 容量在编译确定下来 
               6. start PC:创建的class文件行数
               7. length：生效了多少行
               8. slot:局部变量表中的一个存储单元。long和double占两个slot，其他占一个
               9. 构造器和实例方法中第一个槽位是当前对象的引用this
               10. 对象过了作用域后会服用槽位
            2. 行号对照表
               1. class文件行号和java文件行号对照关系
            3. 操作数栈
               1. 计算过程的中间结果、计算过程变量的临时存储
               2.  在指令的运行过程中将数据存入或取出
               3. 返回值也会被压入栈中
            4. 动态链接
               1. 每个栈帧都有指向 方法区中运行时常量池中这个栈帧所属方法的引用
               2. 编译过程中，所有变量和方法引用都会作为符号引用存在方法区的常量池中。
               3. 动态链接是用于将这些符号引用转换为方法引用
            5. 方法的调用
               1. 链接方式
                  1. 静态链接
                     1. 编译期间可知且保持不变（早期绑定）
                  2. 动态链接
                     1. 只有运行至时间可以确定（晚期绑定） 
               2. 虚方法和非虚方法
                  1. 非虚方法
                     1. 静态方法、私有方法、final方法、实例构造器、父类方法
                     2. 使用invokestatic、invokespecial
                  2. 虚方法
                     1. invokevirtual
                     2. invokeinterface 
                  3. 方法重写的本质
                     1. 本类没有就去找父类，循环找
                     2. JVM方法区有个虚方法表提高性能，存放方法的实际入口。
            6. 方法返回地址
               1. 方法pc寄存器的值
               2. 正常返回时返回到上一个栈帧的寄存器指令位置
               3. 异常返回时不会返回值
               4. ireturn、lreaturn、freturn、dreturn、areturn、return
               5. 异常表会将覆盖的行按异常位置和处理位置对照处理
            7. 附加信息
   5. 本地方法接口
      1. native method时不提供实现类，由非java语言实现
      2. 与c交互、操作系统交互 
   6. 本地方法栈
      1. 管理本地方法的调用
      2. hotspotJAM本地方法栈和虚拟机栈合二为一
   7. 堆
      1. 概述
         1. 物理上可以不连续，逻辑上要连续
         2. 可以划分私有缓冲区TLAB
         3. 数组和对象在栈中保存引用，引用指向堆中位置
         4. 方法结束后堆中对象不会立马移除，只有GC时会移除
         5.   new是堆空间创建对象的指令
         6. 堆是GC重点区域
      2. 内存细分
         1. 新生区
            1. eden
            2. surivor
               1. s1
               2. s2
         2. 老年区
         3. 元空间
      3. 设置堆空间大小
         1. -Xms：默认最大内存/64
         2. -Xmx：默认最大内存/4
         3. 一般设置成一样的防止重新计算
         4. 同一时间只会使用一个surivoi区
         5. jps/jstat -gc 或-XX:PrintGCDetails查看内存情况  
      4. 年轻代和老年代
         1. 年轻代
            1. 几乎所有对象在eden区被new出来。
            2. 大部分java对象在eden销毁
         2. 老年代
         3. 配置
            1. -XX:newRatio=2,默认值是新生代：老年代=1：2
            2. -XX:SurvivorRatiom=8,eden和survivor的比例，默认Eden:Survivor1:survivor2=8:1:1
            3. -XX:useAdaptiveSizePolicy：自适应的eden和survivor占比策略
            4. -Xmn:设置新生代内存大小（一般不用）
      5. GC
         1. 概述
            1. YGC/minor GC
               1. 只对新生代
            2. MAjor GC
               1. 只对老年代
               2. 只有CMS GC会执行
            3. Mixed GC
               1. 整个新生代和部分老年代
               2. 只有G1 GC会执行
            4. Full GC
               1. 整个堆和方法区
            5. 尽量避免大对象
         2. 触发
            1. 新建对象如果eden放不下时触发YGC
            2. 新建对象如果老年代放不下时，触发Minor GC,还不足则触发Major GC
            3. 如果老年代Major GC还放不下则Full GC
            4. 还不足则OOM
            5. 此外
               1. 方法区空间不足会full GC
               2. 老年代空间不足（Major和Full混用）
         3. YGC/miniorGC
            1. 顺序
               1. Eden满时进行YGC/minor GC:回收eden和S2到S1，对象age+1
               2. 多次gc后age超 过15(阈值)的对象进行移动到老年代（promotion）
            2. 逻辑
               1. S0中相同年龄的所有对象大于s0的大小，则大于等于这个年龄的全部进入老年代
         4. major GC
         5. Full GC
         6. 配置
            1. -XX:MAXTenuringThreshold=X,age为多少时放到老年代
      6. TLAB
         1. eden区中为每个线程分配私有缓存区域
         2. TLAB是内存分配的首选
         3. 占eden空间的1%，存不下则放Eden
         4. 配置：
            1. -XX:UseTLAB，是否启用
            2. -XX:TLABWasteTargetPercent，TLAB占Eden空间的百分比
         5. TLAB分配失败才会在Eden创建对象，并加锁
      7. 逃逸分析
         1. 如果一个对象生命周期没有超过方法的话可能在栈上分配
         2. 同步块如果不会被其他线程同时访问到的会进行锁消除
         3. 标量和聚合量。未逃逸的聚合量会被替换为标量存在栈上（方便不使用连续内存空间）
         4. **使对象不逃逸是优化内存的方式**
         5. -XX:DoEscapeAnalysis,逃逸分析
         6. -XX:+PrintEscapeAnalysis
         7. -XX:+EliminateAllocations: 开启标量替换（默认开启）
   8. 方法区
      1. 元空间不在虚拟机内存中，使用本地内存 
      2. -XX:MetaspaceSize，默认21M
      3. -XX:MaxMetaspaceSize，默认没有限制
      4. 当触及21M时，会触发Full GC
      5. 初始设置为较大的值
      6. 存储内容
         1. 类信息
            1. class文件信息
               1. 包名.类名
               2. 父类的全限定名
               3. 类的修饰符
               4. 类实现的直接接口的有序列表
               5. field字段信息
                  1. 名称、类型、修饰符
               6. 方法信息
                  1. 方法名称
                  2. 返回类型
                  3. 参数类型
                  4. 修饰符
                  5. 字节毛、操作数栈、局部变量表
                  6. 异常表
            2. classloader加载器
         2. 运行时常量池
            1. 常量池表
               1. 字节码文件中的字面量和对类型、域、方法的符号引用
            2. 运行时常量池
               1. 就是常量池表放到方法区后的数据
               2. 每个加载的类都维护一个常量池。并通过**索引访问**池中数据。 
               3. 常量池表加载到运行时常量池后独影的符号地址将转换为**真实地址**
               4. **具备动态性**
            3. GC
               1. 主要收集不再使用的常量和类型
                  1. 常量
                     1. 只要没有引用就可以回收
                     2. 字面量
                        1. 文本字符串
                        2. final的常量值
                     3. 符号引用 
                        1. 类型
                           1. 类和接口的全限定名
                           2. 字段的名称和描述符
                           3. 方法的名称和描述符
                        2. 回收条件
                           1. 所有的实例被回收
                           2. 类加载器被回收
                           3. 无法反射访问该类
         3. 静态变量
            1. 静态变量和类关联在一起
            2. final修饰的静态变量编译的时候就赋值了
            3. 
         4. 即时编译器编译后的代码缓存  
   9. 对象
      1. 对象实例化的方式
         1. new
         2. Class的newInstance()：反射方式，只能使用puiblic的空参构造器
         3. Constructor的newInstance()：反射方式，可以调用空参、带参的构造器，没有权限要求
         4. 使用clone()：需要类实现clone接口和clone()方法
         5. 使用反序列化：
         6. 第三方库的Objenesis
      2. 创建对象的步骤
         1. 判断对象的类是否加载、链接、初始化
         2. 为对象分配内存、
            1. 如果内存规整-指针碰撞（往空闲内存方向移动指针）进行分配
            2. 如果内存不规整-按虚拟机维护的空闲列表进行分配
         3. 处理并发安全问题
            1. 采用CAS加失败重试和区域加锁
            2. TLAB
         4. 初始化分配的内存空间。将分配的空间按照类中的字段的引用指向到对应的内存位置。
         5. 设置对象的对象头
            1. 类的元数据信息
            2. 对象的hashCode
            3. GC信息
            4. 锁信息
         6. 执行init方法进行初始化
      3. 对象的内存
         1. 对象头
            1. 运行时元数据
               1. 哈希值 
               2. GC分代年龄
               3. 锁状态标志
               4. 线程持有的锁
               5. 偏向线程id
               6. 偏向时间戳
            2. 类型指针
               1. 指向方法区的klass的元信息
            3. 数组还需要记录长度
         2. 实例数据
            1. 各种类型的字段
            2. 规则
               1. 相同宽度的字段总是被分在一起
               2. 父类定义的变量会出现在子类之前
               3. CompactFields为true时，子类的窄变量会插入到父类变量的空隙中
         3. 对齐填充
            1. 不是必须的
      4. 访问方式
         1. 句柄访问
            1. 指向对象堆中实例数据的指针
            2. 指向对象方法区中类型数据的指针（hotspot）
         2. 直接指针
            1. 对象实例数据
   10. 直接内存
       1. 堆外向系统申请的内存
       2. 来源NIO，通过DirectByteBuffer操作native内存
       3. 不需要用户态到内核态的复制。读写性能好
       4. 不受-xmx限制。不受JVM内存回收管理。
       5. 回收成本高
       6. -XX:MaxDirectMemory=64M,设置大小
4. 执行引擎
   1. JIT编译器
      1. 比解释执行速度快
      2. Client Complier:简单可靠的优化，耗时短
         1. 方法内联：引用的方法直接编译到引用点，防止栈帧的生成
         2. 去虚拟化：只有一个实现类就不用接口
         3. 冗余消除：运行时不执行的代码进行去除

      3. server Colplier：深度优化，耗时长
         1. 标量替换
         2. 栈上分配
         3. 同步消除

   2. 解释器
      1. 初次响应时间快
5. 热点探测
   1. 调用较多的方法会被JIT编译为本地机器指令。并在方法执行过程中发生，所以需要进行栈上替换（ OSR）
   2. 基于计数器的热点探测
      1. 方法调用计数器，统计调用次数
      2. 回边计数器，统计重复次数
      3. 如果在规定时间没有达到触发JIT的次数，则将当前次数/2
      4. -XX:-UseCounterDecay，关闭热度衰减
      5. -XX:CounterHalfLifeTime，设置半衰期时间

   3. -XX:ComplieThreshold,设置触发JIT编译的次数
   4. -Xint:只用解释器
   5. -Xcomp：只用编译器
   6. -XMixed：混合模式
   7. AOT JAOTC: 执行前全部编译成机器指令
      1. 不能一次编译到处运行
      2. 降低了java连接过程的动态性
6. StringTable
   1. String pool 是一个固定长度的HashTable
   2. -XX:StringTableSize调整长度
   3. 常量+常量，结果在常量池中。编译期就已经优化了.
   4. 常量+变量就不会到常量池中。使用StringBuilder实现，最终.toString时返回new String()。两个final修饰的会放入常量池，此时视为3的情况。
   5. String.intern()会将字符串的地址放入常量池中
   6. new String("")会在堆和常量池都创建对象
   7. 常量池占用内存小
   8. -XX:UseStringDeduplication=true,开启String字符串去重
   9. -XX:PrintStringDeduplicationStatistics=true,打印去重信息
   10. -XX:StringDeduplicationAgeThreshold:10,去重检查的年龄阈值
7. GC
   1. 垃圾
      1. 没有任何指针引用的对象

   2. 回收算法
      1. 标记阶段
         1. 引用计数算法
            1. 每个对象保存一个引用计数器属性。
            2. 优点：简单、对象好辨识、判定效率高、没有回收延迟
            3. 缺点：增加存储开销。加减引用计数有时间开销。**无法处理循环引用的问题。**

         2. 可达性分析算法
            1. 从GC Roots 是否可达一个对象
            2. 状态
               1. 可触及的
               2. 可复活的
               3. 不可触及的

            3. 标记中两次标记的过程
               1. 如果没有重写finalize或者finalize已经被调用过，则标记为不可触及
               2. 如果重写了且未执行、则进入F-Queue（虚拟机创建的低优先级的finalizer线程）中执行
               3. GC会堆F-Queue队列中的对象进行二次标记。如果有引用后则移除“即将回收”集合。否则变为不可触及.

            4. GC Roots
               1. 虚拟机栈中对象
               2. 本地方法栈引用的对象
               3. 方法区中静态属性引用的对象
               4. 方法区中常量引用的对象
               5. 所有被同步锁持有的对象
               6. jVM内部的引用，如基本数据类型对应的class对象，异常，系统类加载器
               7. JMXBean，JVMTI中注册的回调、本地代码缓存

      2. 清除阶段
         1. 标记清除算法
            1. 标记:从根节点出发,标记所有可达对象
            2. 清除:对对内从头到尾遍历,对没有标记的对象进行清除.
            3. 缺点
               1. 效率低，需要停止整个程序，清理出的空间不连续

         2. 标记压缩算法
            1.  标记:从根节点出发,标记所有可达对象
            2. 压缩：将存活对象放到内存的一端，清空其他区域
            3. 优点：解决标记清除的内存分散问题、解决复制算法内存减半的问题
            4. 缺点：效率低、需要调整引用地址，需要暂停用户线程

         3. 复制算法
            1. 将使用的复制到另一块空间中
            2. 优点：没有标记清除的过程，效率高。空间能保证连续性。
            3. 缺点：双倍空间。G1内存时间开销较大。存活对象很多的话效率很低。

      3. 对象的finalization机制
         1. 对象销毁前的自定义逻辑
         2. 实现finalize方法 

      4. MAT与JProfile的GC Roots朔源
      5. 分代收集器算法
         1.  年轻代使用复制算法
         2. 老年代使用标记清除或标记压缩
            1. hotspot一般使用标记清除，效果不好时使用标记整理算法

      6. 增量收集算法
         1. 每次收集小块区域，然后切换用户线程
         2. 缺点：短时间减少，总体是更加耗时，造成系统吞吐量下降

      7. 分区算法
         1. 内存划分为小区块，独立使用独立回收。

   3. 垃圾回收相关概念
      1. System.gc()提醒JVM进行Full GC，不一定实际调用。
      2. 安全点和安全区域
         1. gc在安全点才能gc
            1. 抢先式中断：终端所有线程，如果有不在的就恢复，直到到安全点
            2. 主动式中断：设置一个中断标志，轮询所有线程到达这个标志则挂起等待GC

         2. 线程如果在安全区域（对象变化不大）就可以进行GC。在安全区域时GC会忽略这个线程。

      3. 内存溢出和内存泄漏
         1. 内存泄漏：严格上程序不用但是无法回收。宽泛上对象长期无法回收的不使用的对象。
            1. 单例模式引用的外部对象
            2. 数据库连接、网络连接、io链接

      4. 引用
         1. 强引用
            1. 不会被回收

         2. 软引用
            1. 内存不足时会进行回收
            2. 缓存数据

         3. 弱引用
            1. 下次GC都会进行回收

         4. 虚引用
            1. 没听懂

         5. 终结器引用 
            1. 没听懂
8. 垃圾回收器
   1. GC的分类与指标
      1.  按线程分
         1. 串行
         2. 并行

      2. 工作模式
         1. 并发式
         2. 独占式
      3. 碎片处理方式
         1. 压缩式
            1. 再分配方式：指针碰撞

         2. 非压缩式
            1. 再分配方式：空闲列表

      4. 回收器指标
         1. **吞吐量**
            1. 用户线程运行时间占比
            2. 少做GC

         2. 垃圾收集开销
            1. GC时间运行时间占比

         3. **暂停时间**
            1. 工作线程暂停时间
            2. 多做GC

         4. 收集频率
         5. **内存占用**
         6. 快速

      5. 吞吐量、暂停时间、内存占用不可能三角。方向时吞吐量最大的情况下，降低停顿时间。
   2. Serial
      1. Serial GC
         1. 采用复制算法，串行回收和STW执行
      2. Serial Old GC
         1. 采用标记压缩算法，串行回收和STW执行
      3. 优点：简单高效
   3. ParNew GC
      1. 采用复制算法，并行回收和STW执行
   4. parallel
      1. Parallel Scavenge GC
         1. 采用复制算法，并行回收和STW执行
         2. 可控制的吞吐量优先的收集器

      2. Parallel Old GC
         1. 采用标记压缩算法，并行回收和STW执行
   5. CMS回收器
      1. 延迟优先的收集器。达到一定阈值就开始回收了。
      2. 如果回收过程中内存不够用户线程使用，则会使用serial Old进行垃圾回收
      3. 采用标记清除算法、STW执行
         1. 初始标记：标记处GC ROOT能直接访问的对象，速度快
         2. 并发标记：从直接访问对象开始遍历整个对象图，耗时长但是不需要停下用户线程。
         3. 重新标记：修正并发期间用户现场导致变动的对象，速度第二快
         4. 并发清除：删除标记阶段标记死亡的对象，释放内存空间

      4. 优点：并发收集、低延迟
         1. 缺点：产生内存碎片提前产生full GC、无法处理并发标记时用户产生的垃圾、占用部分线程导致吞吐量降低
   6. G1回收器
      1. 延迟可控的话提高吞吐量
      2. 并发与并行
         1. 多个内核并行进行回收
         2. 部分工作可以和用户线程并发执行
      3. 分代收集
         1. Eden、Survior、Old、humongous可以不是连续的内存空间
         2. 堆空间分为若干区域（region）
      4. 空间整合
         1. region之间是复制算法。全局上可以看成标记压缩算法
      5. 可预测的停顿时间模型
         1. 按照限定的时间，收集回收价值最大的几个区域。
      6. 缺点
         1. 运行占用内存和负载更高。G1更适合大内存，6-8G两者表现差不多。
      7. region
         1. 所有region大小相同，JVM生命周期内不会改变
         2. Eden、Survior、Old、humongous。humongous用于存储大对象，G1会寻找连续的H区来存储。
         3. region内部使用指针碰撞，外部维护空闲列表
         4. region中也有tlab
      8. 回收过程
         1. 年轻代GC
            1. eden满了触发回收eden和survivor。
            2. 首先STW，G1创建回收集。  
               1. 扫描根
               2. 更新Remembered Set
               3. 处理Remembered Set
               4. 复制对象
               5. 处理引用
         2. 年轻代GC同时老年代并发标记
            1. 初始标记阶段
               1. 标记从根节点直接可以达的对象，需要STW。
            2. 根区域扫描
               1. 扫描Survivor区域直接可达的老年代引用对象，并标记
            3. 并发标记
               1. 在整个堆中进行并发标记。如果一个区域全是垃圾则直接回收。并计算区域的活性（存活对象比例）
            4. 再次标记
               1. 由于程序持续运行，需要STW再收集新产生的对象。使用了更快的快照算法SATB。
            5. 独占清理
               1. STW，计算区域的存活对象和GC回收比例，并进行排序。这里不会实际进行回收。
            6. 并发清理
               1. 识别并清理空闲区域
         3. 混合回收
            1. 内存超过45%时进行mixed GC。
            2. 只回收一部分老年代。垃圾越多越容易被回收。只有垃圾超过一定百分比才会被回收。
         4. Full GC
            1. GC时没有足够空间复制对象
            2. 并发处理完成前内存耗尽
      9. Remembered Set
         1. 每个region一个。
         2. 用于记录当前region中的对象被其他哪些region引用
         3. 其中的引用当GC Roots
      10. 总结
          1. 避免指定年轻代大小
          2. 暂停时间不能太严苛
   7. 垃圾回收器总结



### 性能监控与调优







---

其他



1. jvm配置
   1. -XX：+PringFlagsInitial，打印参数默认初始值
   2. -XX:+PrintFlagsFinal，打印参数最终值
   3. -Xms：默认最大内存/64
   4. -Xmx：默认最大内存/4
   5. -XX:newRatio=2,默认值是新生代：老年代=1：2
   6. -XX:SurvivorRatiom=8,eden和survivor的比例，默认Eden:Survivor1:survivor2=8:1:1
   7. -XX:useAdaptiveSizePolicy：自适应的eden和survivor占比策略
   8. -Xmn:设置新生代内存大小（一般不用）
   9. -b XX:MAXTenuringThreshold=X,age为多少时放到老年代
   10. -XX:UseTLAB，是否启用
   11. -XX:TLABWasteTargetPercent，TLAB占Eden空间的百分比
   12. -XX:+PrintGCDetails：打印GC详细信息
   13. -XX:+PrintGC ：打印GC简单信息
   14. -verbose:gc：打印GC简单信息
   15. -XX：HandlePromotionFailure：老年代寸的下新生代就只进行minorGC，否则full gc
   16. -XX:DoEscapeAnalysis,逃逸分析
   17. -server:启动server模式，启用逃逸分析
   18. -XX:MaxDirectMemory=64M,设置直接内存大小
   19. -XX:-UseCounterDecay，关闭JIT 热度衰减
   20. -XX:CounterHalfLifeTime，设置JIT半衰期时间
   21. -XX:ComplieThreshold,设置触发JIT编译的次数
   22. -Xint:只用解释器
   23. -Xcomp：只用编译器
   24. -XMixed：混合编译解释模式
   25. -XX:StringTableSize调整长度 
   26. -XX:+PringtCommandLineFlags，打印参数
   27. GC
       1. -XX:+PrintGC,输出GC日志
       2. -XX:+UseSerialGC，使用单线程垃圾收集器
       3. -XX:+UseParNewGC，使用parnewGC
       4. -XX:UseParallelGC，使用parallelGC
       5. -XX:ParallelGCThreads，GC线程数量
       6. -XX:MaxGCPauseMillis，STW最大暂停时间
       7. -XX:GCTimeRatio,工作线程时间/垃圾回收时间的值
       8. **-XX:+UseAdaptiveSizePolicy**，设置parallel Scavenge收集器的自适应调节，这个配置自动调节堆空间的比例
       9. -XX:+UseCMSCompctAtFullCollection,fullGC后进行内存整理
       10. -XX:COMFullGCsBeforeCompation: 在多少次fullGC后对内存空间进行整理
       11. -XX:ParallelCMSThreads,设置线程数量
       12. -XX:+UseConcMarkSweepGC:手动指定CMS收集器
       13. -XX:CMSLnitiatingOccupanyFraction:设置堆内存阈值
       14. -XX:+UseG1GC，使用G1收集器
       15. -XX:G1HeapRegionSize,设置region大小,2的幂，1-32MB之间
       16. -XX:MAxGCPauseMillis，GC最大停顿时间
       17. -XX:ParallelGCThread,设置GC的工作线程
       18. -XX:ConcGCThreads: 设置并发标记的线程数量
       19. -XX:InitiatingHeapOccupancyPercent，触发GC的堆占用的阈值
       20. -XX:G1MixedGCLiveThresholdPercent:G1回收器触发老年代region回收的垃圾占比
2. jps：查找java进程
3. jstat
   1. -gc：查看内存情况
      1. oc：总量
      2. ou：使用量
      3. ec:eden区总量
      4. eu:eden区使用量
      5. s0c：S0总量
      6. s1c：s1总量
      7. s0u：s0使用
      8. s1u：s1使用
4. jinfo
   1. -flag 
      1. survivoirRatio：堆老年代占比
      2. newRatio:堆新生代占比
5. jmap
6. MAT
7. Jcnosole
8. VisualVM
9. Jprofiler
10. JAVA flight Recorder
11. GCviewer

ref: https://www.bilibili.com/video/BV1PJ411n7xZ?spm_id_from=333.788.player.switch&vd_source=e16c9ac38903f1726b7c085d46c20547&p=33